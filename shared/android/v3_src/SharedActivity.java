//This is shared between all android p+ projects so be careful!
//Thanks to Phil Hassey for his help and code

//NOTE:  Do not edit this file after it's been copied to your project in the Gradle build or it will get overwritten - instead, edit the version in proton/shared/android/v3_src
//Most of this was written when Android was at version 2, so yeah, it's crust and should probably be rewritten but ...

package com.rtsoft.RTAndroidApp;
import com.rtsoft.RTAndroidApp.SharedMultiTouchInput;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import android.app.Activity;
import android.os.SystemClock;
import android.text.ClipboardManager;
import android.app.AlertDialog;
import android.app.Dialog;
import android.os.Build;
import android.os.Environment;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import org.json.JSONObject;
import android.content.DialogInterface;
import android.widget.Button;
import android.widget.TextView;
import android.widget.EditText;
import android.provider.Settings.Secure;
import android.view.ViewGroup;
import android.content.Context;
import android.view.KeyEvent;
import android.view.inputmethod.InputMethodManager;
import android.opengl.GLSurfaceView;
import android.graphics.PixelFormat;
import android.view.InputDevice;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputConnection;
import android.view.View.OnKeyListener;
import android.text.InputType;
import android.view.inputmethod.BaseInputConnection;
import android.text.Editable;
import android.text.Selection;
import android.view.KeyCharacterMap;
import android.view.ActionMode;
import android.view.Menu;
import android.text.InputFilter;
import android.view.MenuItem;
import android.text.TextWatcher;
import android.view.View.OnFocusChangeListener;
import android.graphics.Color;


import android.os.Bundle;
import android.os.Vibrator;
import android.view.MotionEvent;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import android.util.Log;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.AssetFileDescriptor;
import android.content.res.AssetManager;
import android.content.pm.PackageInfo;


// Wifi
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;



import java.util.List;
import java.io.File;
import java.io.FileOutputStream;

import android.media.MediaPlayer;
import android.content.res.AssetFileDescriptor;
import android.media.SoundPool;
import android.media.AudioManager;
import java.util.Locale;

import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.telephony.ServiceState;
import android.telephony.TelephonyManager;

import android.os.Handler;
import android.view.View;
import android.view.ViewGroup.LayoutParams;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import android.view.View.OnClickListener;
import android.net.ConnectivityManager;


	public class SharedActivity extends Activity implements SensorEventListener

{

	//********** THESE WILL BE OVERRIDDEN IN YOUR Main.java file **************
	public static String PackageName= "com.rtsoft.something";
	public static String dllname= "rtsomething";
	public static boolean securityEnabled = false; //if false, it won't try to use the online license stuff
	public static boolean bIsShuttingDown = false;
	public static boolean IAPEnabled = false; //if false, IAB won't be initted.  I call it IAP because I'm used to it from iOS land
	
	public static String tapBannerSize = ""; //tapjoy banner size text, set in Main.cpp, or by AdManager calls
	public static int adBannerWidth = 0;
	public static int adBannerHeight = 0;
	
	public static String m_iap_asap = "";
	public static String m_iap_sync_purchases_asap = "";
	public static String m_iap_consume_asap = "";
	public static String m_iap_developerdata = "";
	
	public static String m_advertiserID = ""; //only will be set it Google Services is added to the project.   This is a big hassle for Proton projects,
	//I ended up just copying over the res and jar manually because android.library.reference.1= in project.properties didn't seem to let the manifest access the .res and.. argh.
	public static boolean m_limitAdTracking = false;

	public static boolean m_focusOnKeyboard = false;
	public static boolean m_focusOffKeyboard = false;
	
//#if defined(RT_FLURRY_SUPPORT)
	public static String m_flurryAPIKey = "";	
//#endif

	public static boolean HookedEnabled = false;
	//************************************************************************
    static final int RC_REQUEST = 10001;


	public static SharedActivity app = null; //a global to use in static functions with JNI
	
	//for the accelerometer
	private static float accelHzSave     = 0;
    private static Sensor sensor;
    private static SensorManager sensorManager;
	private static float m_lastMusicVol = 1;
	public static int apiVersion;
	
	//TAPJOY
	
	public static View adView;
	public static RelativeLayout adLinearLayout;
	public static EditText m_editText;
	public static String m_before="";
	public static String m_spacer = "                                               ";
	
	public static int m_text_max_length = 20;
	public static String m_text_default = "";
	public static boolean update_display_ad;
	public static boolean run_hooked;
	public static int tapjoy_ad_show; //0 for don't shot, 1 for show
	public static String m_externalDir="";
	
	public static boolean set_allow_dimming_asap = false;
	public static boolean set_disallow_dimming_asap = false;

	public Map<Integer, Integer> m_gamepadMap = new HashMap<>();
    ////////////////////////////////////////////////////////////////////////////
	final Handler mMainThreadHandler = new Handler();

	final static int C_CONTROLLER_MAPPING_PS5 = 0;
	final static int C_CONTROLLER_MAPPING_XBOX = 1;
	final static int C_CONTROLLER_MAPPING_PS4 = 2;
	final static int C_CONTROLLER_MAPPING_SWITCH_PRO = 3;
	final static int C_CONTROLLER_MAPPING_8BITDO = 4;

	@Override
	protected void onDestroy()
     {
     	Log.d(PackageName, "Destroying...");
		
        super.onDestroy();
    }

    @Override
    protected void onStart() 
    {
        super.onStart();

    }

    @Override
    protected void onStop()
    {
        super.onStop();

    }

	@Override
	public void onBackPressed() 
{

        super.onBackPressed();
}

    void alert(String message)
     {
        AlertDialog.Builder bld = new AlertDialog.Builder(this);
        bld.setMessage(message);
        bld.setNeutralButton("OK", null);
        Log.d(PackageName, "Showing alert dialog: " + message);
        bld.create().show();
    }
	 void complain(String message)
	 {
        Log.e(PackageName, "Initialization error: " + message);
        alert("Error: " + message);
     }
    
	@Override
    protected void onCreate(Bundle savedInstanceState) 
	{
        app = this;
		m_externalDir = this.getExternalFilesDir(null).getAbsolutePath();
		apiVersion = Build.VERSION.SDK_INT;
	    Log.d(PackageName, "***********************************************************************");
		Log.d(PackageName, "API Level: " + apiVersion);
	
		super.onCreate(savedInstanceState);
        mGLView = new AppGLSurfaceView(this, this);
    	
		setContentView(mGLView);
	  
	  //if (apiVersion > 15) //use new input system because Google sucks.  Using on all not just newer now
	  {
	  
	   Log.d(app.PackageName, "Setting up new input system");
      
	  m_editText = new EditText(this);
	  m_editText.setText("");
      m_editText.setImeOptions(EditorInfo.IME_FLAG_NO_FULLSCREEN|EditorInfo.IME_FLAG_NO_EXTRACT_UI| EditorInfo.IME_FLAG_FORCE_ASCII);
	  
    m_editText.setOnFocusChangeListener(new OnFocusChangeListener() {          
 @Override
        public void onFocusChange(View v, boolean hasFocus) {
            if(!hasFocus)
            {
              // Log.d(app.PackageName, "Edittext lost focus");
            } else
            {
              // Log.d(app.PackageName, "Edittext got focus");
      
            }
        }
    });
       
   
	m_editText.setInputType(InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD);
 	
	try
		{
        	m_editText.setCustomSelectionActionModeCallback(new ActionMode.Callback() {
 @Override
    public boolean onCreateActionMode(ActionMode actionMode, Menu menu) {
        return false;
    }

    public boolean onPrepareActionMode(ActionMode actionMode, Menu menu) {
        return false;
    }

    public boolean onActionItemClicked(ActionMode actionMode, MenuItem item) {
        return false;
    }

    public void onDestroyActionMode(ActionMode actionMode) {
    }
});
	
		} 
		catch (NoClassDefFoundError ex) 
		{
           //	Log.d(PackageName, "setCustomSelectionActionModeCallback(> Avoided crash. "+ex);
		}
        	
       	//Log.d(PackageName, "Passed setCustomSelectionActionModeCallback");
	
	try
		{
m_editText.setOnEditorActionListener(new EditText.OnEditorActionListener() {
    @Override
    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_SEARCH || actionId == EditorInfo.IME_ACTION_DONE) 
        {
          	InputMethodManager mgr = (InputMethodManager)app.getSystemService(Context.INPUT_METHOD_SERVICE);
		    mgr.hideSoftInputFromWindow (mGLView.getWindowToken(),0);
      
            Log.d(app.PackageName, "editor action says we're done editing text");
           	SharedActivity.app.nativeOnKey(1, 13, 13); //fake enter key
            
        	mGLView.requestFocus();
			m_editText.setText("");
            return true;
        }
        return false;
    }
});

	} 
		catch (NoClassDefFoundError ex) 
		{
           	Log.d(PackageName, "setOnEditorActionListener(> Avoided crash. "+ex);
		}
		
m_editText.addTextChangedListener(new TextWatcher() 
{

          public void afterTextChanged(Editable s) 
          {
			  //Log.d(app.PackageName, "Setting text to "+ SharedActivity.app.m_before);

			 //s.setText(SharedActivity.app.m_before);
          }

          public void beforeTextChanged(CharSequence s, int start, int count, int after) 
          {
	        // Log.d(app.PackageName, "beforeTextChanged: "+count+" chars changed. start is "+start+" and After: "+after+" String: "+s);
      
          }

          public void onTextChanged(CharSequence s, int start, int before, int count) 
          {
          //grab the last char entered and send to Proton
          //Log.d(app.PackageName, "onTextChanged: "+count+" chars changed. start is "+start+" and before is "+before+". m_before.length is "+m_before.length());
			//  Log.d(app.PackageName, "m_before is: "+m_before);

			  if (m_before.length() > s.length())
          		{
          			//string is now smaller, either a cut, clear or delete.  Let's assume delete for Proton's simple native input
          			m_before = s.toString();
		  			SharedActivity.app.nativeOnKey(1, 67, 0);
					//Log.d(app.PackageName, "Doing del");
					return;
          		} else
          		
          		if (s.length() > m_before.length())
          		{
          			if (s.length() > start)
				  {
					 // Log.d(app.PackageName, "Adding char: s.length "+s.length()+" and start is "+start);

					  
					  char changedChar = s.charAt(start);
          				SharedActivity.app.nativeOnKey(1, 0, changedChar);
            			SharedActivity.app.nativeOnKey(0, 0, changedChar);
          		  }
          		} else
          		{
          			//Log.d(app.PackageName, "nothing changed.  Must be del?");

				}

			  //Log.d(app.PackageName, "Setting m_before to "+s.toString());

			  m_before = s.toString();
	
          }
       });
	
		m_editText.setLongClickable(false);
		
		try
		{
		m_editText.setTextIsSelectable(false);
		} 
		catch (NoSuchMethodError ex) 
		{
           	Log.d(PackageName, "setTextIsSelectable(> Avoided crash. "+ex);
		}
		m_editText.setBackgroundColor(Color.TRANSPARENT);
		m_editText.setTextColor(Color.TRANSPARENT);
		m_editText.setCursorVisible(false);

		addContentView(m_editText, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
		mGLView.requestFocus();
	//end new input stuff
  }
	
		setVolumeControlStream(AudioManager.STREAM_MUSIC);

		
		Log.d(PackageName, "Checking for controllers...");

		CheckControllers();

		update_display_ad = false;
		run_hooked = false;
		tapjoy_ad_show = 0;

		sendVersionDetails();
    }


//#endif

	public void CheckControllers()
	{
		Log.d(PackageName, "Yeah, checking for controllers...");

		SharedActivity.app.m_gamepadMap.clear();


		int[] deviceIds = InputDevice.getDeviceIds();
		for (int deviceId : deviceIds)
		{
			InputDevice dev = InputDevice.getDevice(deviceId);
			int sources = dev.getSources();

			// Verify that the device has gamepad buttons, control sticks, or both.
			if (((sources & InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD)
					|| ((sources & InputDevice.SOURCE_JOYSTICK)
					== InputDevice.SOURCE_JOYSTICK))
			{
				String deviceName = dev.getName().toLowerCase();

				//2508 (Wireless Controller Touchpad) = PS4 bluecontroller
				//3302 (Wireless Controller) = PS5 (launch?)
				//2835 (Xbox Wireless Controller) = Robot White XBOX 1X controller, Also Black model
				//2850 (Xbox Wireless Controller) = Elite Series 2 (Same button layout as above)

				//8201 (Nintendo Switch Pro Controller) = Green & Pink Pro Controller

				//24835 8BitDo Pro 2 (D setting for pairing, required 8bitdo ultimate software installed on device before it worked)
				//24834 (8BitDo SN30 Pro+) 8BitDo SN30 Pro+ Black, 5.04 firmware


				Log.d(PackageName, "Found controller "+dev.getName()+" ProductID: "+dev.getProductId());
				if (deviceName.contains("Wireless Controller Touchpad") || dev.getProductId() == 2508)
				{
					m_gamepadMap.put(deviceId, C_CONTROLLER_MAPPING_PS4);
				} else
				if (dev.getProductId() == 3302) //ps5.  Matching on "Wireless Controller" seems dangerously generic
				{
					m_gamepadMap.put(deviceId, C_CONTROLLER_MAPPING_PS5);
				} else
				if (
					deviceName.contains("Nintendo Switch Pro Controller") || dev.getProductId() == 8201
				)
				{
					m_gamepadMap.put(deviceId, C_CONTROLLER_MAPPING_SWITCH_PRO);
				} else
				if (
					deviceName.contains("8BitDo SN30 Pro") || dev.getProductId() == 24834
  					|| deviceName.contains("8BitDo Pro 2") || dev.getProductId() == 24835
					)
					{
						m_gamepadMap.put(deviceId, C_CONTROLLER_MAPPING_8BITDO);
					} else
				{
					m_gamepadMap.put(deviceId, C_CONTROLLER_MAPPING_XBOX);  //default
				}

			}
		}

	}


    @Override
    protected synchronized void onPause()
	{
		float hzTemp = accelHzSave;
	    setup_accel(0); //disable accelerator messages to save on CPU/battery
		accelHzSave = hzTemp;
        mGLView.onPause();
        super.onPause();
		//_sounds.autoPause();

	
    }

    @Override
	protected synchronized void onResume()
	{
		//_sounds.autoResume();
	
		music_set_volume(m_lastMusicVol); //android forgets the audio level, need to reset it
        mGLView.onResume();
		setup_accel(accelHzSave);
		super.onResume();


					
	}
	
	// Create runnable for posting
	final Runnable mUpdateMainThread = new Runnable() 
	{
		public void run() 
		{
			if (app.bIsShuttingDown)
			{
				//Log.d(PackageName, "Finished app in  main thread");
				app.finish();

				android.os.Process.killProcess(android.os.Process.myPid());
				return;
			}
			updateResultsInUi();
		}
	};
 
 
	private void updateResultsInUi() 
	{
	
		if (set_allow_dimming_asap)
		{
			set_allow_dimming_asap = false;
			Log.d(app.PackageName, "Allowing screen dimming.");
			mGLView.setKeepScreenOn(false);
		}

		if (set_disallow_dimming_asap)
		{
			set_allow_dimming_asap = false;
			Log.d(app.PackageName, "Disabling screen dimming.");
			mGLView.setKeepScreenOn(true);
		}
		
		if (m_focusOnKeyboard)
		{
			m_focusOnKeyboard = false;
			int maxLength = m_text_max_length;
		
			if (m_editText != null)
			{
				/*
				InputFilter[] FilterArray = new InputFilter[1];
				FilterArray[0] = new InputFilter.LengthFilter(maxLength);
				m_editText.setFilters(FilterArray);
				*/
				//This is a horrible hack because Android won't send backspace events in some
				//cases if we don't, it's complicated to explain but blame Android
				m_editText.setText(m_text_default);
				SharedActivity.app.m_before = m_text_default;
				
				m_editText.setSelection( m_editText.getText().length()); 
				
				m_editText.requestFocus();
				//Log.d(app.PackageName, "m_before is now "+m_before);

			}
		}
		
		if (m_focusOffKeyboard)
		{
			m_focusOffKeyboard = false;
	
			if (m_editText != null)
			{
				mGLView.requestFocus();
			}
		}

		

	}

	// JNI used to get Save data dir
    public static String get_docdir() 
	{
		File fdir = app.getFilesDir();
     	return fdir.getAbsolutePath();
    }
 	
	
	public static String get_externaldir()
	{
		return app.m_externalDir;
		
	}


	public static void SetPackageName(String packageID)
	{
		PackageName = packageID;
	}
	
	// JNI used to get Save data dir
    public static String get_apkFileName() 
	{
		String apkFilePath = null;
		ApplicationInfo appInfo = null;
		PackageManager packMgmr = app.getPackageManager();
		try {
			appInfo = packMgmr.getApplicationInfo(PackageName, 0);
		} 
		catch (NameNotFoundException e) 
		{
			e.printStackTrace();
			throw new RuntimeException("Unable to locate assets, aborting...");
		}

		Log.d(PackageName, "APK located from "+PackageName+": "+appInfo.sourceDir);
 		return appInfo.sourceDir;	
	 }

	public static String get_region()
	{
		//will return region in the format "en_us"
		Locale l = java.util.Locale.getDefault();    
		return (l.getLanguage()+"_"+l.getCountry()).toLowerCase();
	}
	
		public static int is_app_installed(String packageName)
	{
		//will return 1 if the app is installed
		try
		{
			 ApplicationInfo info = app.getPackageManager().getApplicationInfo(packageName, 0 );
			return 1;
		} catch( PackageManager.NameNotFoundException e )
		{
			return 0;
		}
		
	}

	public static String get_clipboard()
	{
		//Note: On Honeycomb this appears to cause a crash because it has to be done in the main thread, which isn't active when
		//JNI invokes this.  So we have to do a callback and send back the answer later? Argh.  For now, I'll try/catch the crash, it
		//will just be a no-op.
	
		String data = "Thread error, sorry, paste can't be used here.";
	
		try
		{
        	ClipboardManager clipboard = (ClipboardManager) app.getSystemService(CLIPBOARD_SERVICE);
			data = clipboard.getText().toString();
		} 
		catch (Exception ex) 
		{
           	Log.d(PackageName, "get_clipboard> Avoided crash. "+ex);
		}
		return data;
	}
	
	public static String get_deviceID()
	{
		String m_szDevIDShort = "35" + //we make this look like a valid IMEI
								Build.BOARD.length()%10+ Build.BRAND.length()%10 +
								Build.CPU_ABI.length()%10 + Build.DEVICE.length()%10 +
								Build.DISPLAY.length()%10 + Build.HOST.length()%10 +
								Build.ID.length()%10 + Build.MANUFACTURER.length()%10 +
								Build.MODEL.length()%10 + Build.PRODUCT.length()%10 +
								Build.TAGS.length()%10 + Build.TYPE.length()%10 +
								Build.USER.length()%10 ; //13 digits

		
								
	    if (app.checkCallingOrSelfPermission("android.permission.READ_PHONE_STATE") == PackageManager.PERMISSION_GRANTED)
		{
		
		/*

		this method is depreciated, I think we're supposed to use getImei() anyway.  Lint fails if I build an app that doesn't have the right permision

		   TelephonyManager tm = (TelephonyManager) app.getSystemService(Context.TELEPHONY_SERVICE);
			final String DeviceId, SerialNum;
			DeviceId = tm.getDeviceId();
			SerialNum = tm.getSimSerialNumber();
			return m_szDevIDShort + DeviceId + SerialNum;
			*/

			return m_szDevIDShort;
		} 
		else
		{
			return m_szDevIDShort;
		}
	}

public static String get_macAddress()
	{
	//depreciated
	/*
	WifiManager wimanager = (WifiManager) app.getSystemService(Context.WIFI_SERVICE);
     String macAddress = wimanager.getConnectionInfo().getMacAddress();
     
     if (macAddress == null) 
		{
		    macAddress = ""; //blank to signal we couldn't get it
	    }
    */

	 String macAddress = "";
    return macAddress;
	}
	
	
  private static boolean hasSuperuserApk()
  {
    return new File("/system/app/Superuser.apk").exists();
  }
  private static int isTestKeyBuild()
  {
    String str = Build.TAGS;
    if ((str != null) && (str.contains("test-keys")));
    for (int i = 1; ; i = 0)
      return i;
  }
  
public static String get_advertisingIdentifier()
	{
		return app.m_advertiserID;
	}
	
	public static String get_cantSupportTrees()
	{
		if (
		hasSuperuserApk() ||
		is_app_installed("com.noshufou.android.su") == 1 ||
		is_app_installed("com.thirdparty.superuser") == 1 ||
		is_app_installed("eu.chainfire.supersu") == 1 ||
		is_app_installed("com.koushikdutta.superuser") == 1 ||
		is_app_installed("com.zachspong.temprootremovejb") == 1 ||
		is_app_installed("com.ramdroid.appquarantine") == 1 ||
		is_app_installed("cyanogenmod.superuser") == 1 ||
		is_app_installed("com.devadvance.rootcloakplus") == 1
		
		
		
		) return "0";
		return "4322";
	}

public static String get_getNetworkType()
	{


	/*
		ConnectivityManager connManager = (ConnectivityManager)app.getSystemService(Context.CONNECTIVITY_SERVICE);
		try{
			if (connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI).isConnected()) {
			    // Wifi is connected
				return "wifi";
			}
			else if(connManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).isConnected()){
				// Mobile connection available
				return "mobile";
			}else{
				// No connection available
				return "none";
			}	
		}
		catch(Exception e){
			Log.d("DeviceNetwork", e.getMessage());
		}
		*/

		return "none";
	}
	
  @Override
	public void onSensorChanged(SensorEvent event) 
	{
        switch (event.sensor.getType())
		{
            case Sensor.TYPE_ACCELEROMETER:
				if (event.values.length < 3) 
					return; //who knows what this is
				//		Log.d(PackageName, "Accel: " + "x:"+Float.toString(event.values[0]) + " y:"+Float.toString(event.values[1]) + " z:"+Float.toString(event.values[2]));
   				nativeOnAccelerometerUpdate(event.values[0], event.values[1], event.values[2]);
				break;

	        case Sensor.TYPE_ORIENTATION:
				//Log.d(PackageName, "Orientation: " + "x:"+Float.toString(event.values[0]));
				break;
        }
    }
	
  @Override
	public void onAccuracyChanged(Sensor sensor, int accuracy)
	{
    	//Log.d(PackageName,"onAccuracyChanged: " + sensor + ", accuracy: " + accuracy);
    }

	public void setup_accel(float hz) //0 to disable
	{
	  	accelHzSave = hz;
		sensorManager = (SensorManager) app.getSystemService(Context.SENSOR_SERVICE);
		sensorManager.unregisterListener(this);

		if (hz > 0)
		{
			sensorManager.registerListener(app, sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), sensorManager.SENSOR_DELAY_GAME);
		}
		
		//if we ever need orientation data, do this:
		//sensorManager.registerListener(app, sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION), sensorManager.SENSOR_DELAY_GAME);
	}
	

	
	/**
     * The listener that listen to events from the accelerometer listener
     */
    
	// JNI to open_url
    public static void LaunchURL(String url)
	{
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(url));
        app.startActivity(intent);
    }

	public static void create_dir_recursively(String basepath, String path)
	{
		//Log.v("create_dir_recursively", "base: "+basepath+" path: "+path);
		String finalPath = basepath+path;
		File myDir = new File(finalPath);
		myDir.mkdirs();
	}

	public void toggle_keyboard(boolean show) 
	{
		InputMethodManager mgr = (InputMethodManager)app.getSystemService(Context.INPUT_METHOD_SERVICE);
        mgr.hideSoftInputFromWindow (mGLView.getWindowToken(),0);
        if (show) 
		{
            Log.d("Msg","Enabling keyboard");
			mgr.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
            m_focusOnKeyboard = true;
             
            // On the Nexus One, SHOW_FORCED makes it impossible
            // to manually dismiss the keyboard.
            // On the Droid SHOW_IMPLICIT doesn't bring up the keyboard.
        } 
		else
        {
            m_focusOnKeyboard = false;
			Log.d("Msg", "Disabling keyboard");
	    }
    }

	//from MessageManager.h
	final static int VIRTUAL_KEY_BACK = 500000;
	final static int VIRTUAL_KEY_PROPERTIES = 500001;
	final static int VIRTUAL_KEY_HOME = 500002;
	final static int VIRTUAL_KEY_SEARCH = 500003;
	final static int VIRTUAL_KEY_DIR_UP = 500004;
	final static int VIRTUAL_KEY_DIR_DOWN = 500005;
	final static int VIRTUAL_KEY_DIR_LEFT = 500006;
	final static int VIRTUAL_KEY_DIR_RIGHT = 500007;
	final static int VIRTUAL_KEY_DIR_CENTER = 500008;
	final static int VIRTUAL_KEY_VOLUME_UP = 500009;
	final static int VIRTUAL_KEY_VOLUME_DOWN = 500010;
	final static int VIRTUAL_KEY_SHIFT = 500011;
	final static int VIRTUAL_KEY_ALT = 500012;
	final static int VIRTUAL_KEY_CONTROL = 500013;
	final static int VIRTUAL_KEY_TRACKBALL_DOWN = 500035;
	final static int VIRTUAL_DPAD_BUTTON_LEFT = 500036; //square on xperia
	final static int VIRTUAL_DPAD_BUTTON_UP = 500037; //triangle on xperia
	final static int VIRTUAL_DPAD_BUTTON_RIGHT = 500038; //O
	final static int VIRTUAL_DPAD_BUTTON_DOWN = 500039; //X
	final static int VIRTUAL_DPAD_SELECT = 500040;
	final static int VIRTUAL_DPAD_START = 500041;
	final static int VIRTUAL_DPAD_LBUTTON = 500042;
	final static int VIRTUAL_DPAD_RBUTTON = 500043;
	final static int VIRTUAL_DPAD_LTRIGGER = 500044;
    final static int VIRTUAL_DPAD_RTRIGGER = 500045;
	
	final static int VIRTUAL_KEY_GAME_JUMP = 500056;
	final static int VIRTUAL_JOYSTICK_BUTTON_LEFT = 500057; //you know, like how you can push a joystick "in" and it clicks?
	final static int VIRTUAL_JOYSTICK_BUTTON_RIGHT = 500058;

	
//messages we could call on Proton using nativeSendGUIEx:
	final static int MESSAGE_TYPE_GUI_CLICK_START = 0;
	final static int MESSAGE_TYPE_GUI_CLICK_END = 1;
	final static int MESSAGE_TYPE_GUI_CLICK_MOVE = 2; //only send when button/finger is held down
	final static int MESSAGE_TYPE_GUI_CLICK_MOVE_RAW = 3; //win only, the raw mouse move messages
	final static int MESSAGE_TYPE_GUI_ACCELEROMETER = 4;
	final static int MESSAGE_TYPE_GUI_TRACKBALL = 5;
	final static int MESSAGE_TYPE_GUI_CHAR = 6; //the input box uses it on windows since we don't have a virtual keyboard
	final static int MESSAGE_TYPE_GUI_COPY = 7;
	final static int MESSAGE_TYPE_GUI_PASTE = 8;
	final static int MESSAGE_TYPE_GUI_TOGGLE_FULLSCREEN = 9;

	final static int MESSAGE_TYPE_SET_ENTITY_VARIANT = 10;
	final static int MESSAGE_TYPE_CALL_ENTITY_FUNCTION = 11;
	final static int MESSAGE_TYPE_CALL_COMPONENT_FUNCTION_BY_NAME = 12;
	final static int MESSAGE_TYPE_PLAY_SOUND = 13;
	final static int MESSAGE_TYPE_VIBRATE = 14;
	final static int MESSAGE_TYPE_REMOVE_COMPONENT = 15;
	final static int MESSAGE_TYPE_ADD_COMPONENT = 16;
	final static int MESSAGE_TYPE_OS_CONNECTION_CHECKED = 17; //sent by macOS, will send an eOSSTreamEvent as parm1
	final static int MESSAGE_TYPE_PLAY_MUSIC = 18;
	final static int MESSAGE_TYPE_UNKNOWN = 19;
	final static int MESSAGE_TYPE_PRELOAD_SOUND = 20;
	final static int MESSAGE_TYPE_GUI_CHAR_RAW = 21;
	final static int MESSAGE_TYPE_SET_SOUND_ENABLED = 22;
	
	//some tapjoy stuff
	final static int MESSAGE_TYPE_TAPJOY_AD_READY = 23;
	final static int MESSAGE_TYPE_TAPJOY_FEATURED_APP_READY = 24;
	final static int MESSAGE_TYPE_TAPJOY_MOVIE_AD_READY = 25;

	//GOOGLE BILLING
	final static int MESSAGE_TYPE_IAP_RESULT = 26;
	final static int MESSAGE_TYPE_IAP_ITEM_STATE = 27;
	final static int MESSAGE_TYPE_IAP_ITEM_INFO_RESULT = 52;
	
	//more tapjoy stuff
	final static int MESSAGE_TYPE_TAPJOY_TAP_POINTS_RETURN = 28;
	final static int MESSAGE_TYPE_TAPJOY_TAP_POINTS_RETURN_ERROR = 29;
	final static int MESSAGE_TYPE_TAPJOY_SPEND_TAP_POINTS_RETURN = 30;
	final static int MESSAGE_TYPE_TAPJOY_SPEND_TAP_POINTS_RETURN_ERROR = 31;
	final static int MESSAGE_TYPE_TAPJOY_AWARD_TAP_POINTS_RETURN = 32;
	final static int MESSAGE_TYPE_TAPJOY_AWARD_TAP_POINTS_RETURN_ERROR = 33;
	final static int MESSAGE_TYPE_TAPJOY_EARNED_TAP_POINTS = 34;

	final static int MESSAGE_TYPE_GUI_JOYPAD_BUTTONS = 35; //For Jake's android gamepad input
	final static int MESSAGE_TYPE_GUI_JOYPAD = 36; //For Jake's android gamepad input
	final static int MESSAGE_TYPE_GUI_JOYPAD_CONNECT = 37; // For Jakes android gamepad input
	final static int MESSAGE_TYPE_CALL_ENTITY_FUNCTION_RECURSIVELY = 38; //used to schedule fake clicks, helps me with debugging
	
	final static int MESSAGE_TYPE_HW_TOUCH_KEYBOARD_WILL_SHOW = 39; //ios only, when not using external keyboard
	final static int MESSAGE_TYPE_HW_TOUCH_KEYBOARD_WILL_HIDE = 40; //ios only, when not using external keyboard
	final static int MESSAGE_TYPE_HW_KEYBOARD_INPUT_ENDING = 41; //proton is done with input and requesting that the keyboard hid
	final static int MESSAGE_TYPE_HW_KEYBOARD_INPUT_STARTING = 42; //proton is asking for the keyboard to open
   
	//GOOGLE BILLING again
	final static int MESSAGE_TYPE_IAP_PURCHASED_LIST_STATE = 43; //for sending back lists of items we've already purchased

	final static int MESSAGE_TYPE_CALL_STATIC_FUNCTION = 44; // use by other platforms, but this value needs to be reserved by those platforms.

	// for sending through version values
	final static int MESSAGE_TYPE_APP_VERSION = 45;

	final static int MESSAGE_USER = 1000; //send your own messages after this #
	
	//IAP RESPONSE CODES for Proton
	final static int RESULT_OK = 0;
	final static int RESULT_USER_CANCELED = 1;
	final static int RESULT_SERVICE_UNAVAILABLE = 2;
	final static int RESULT_BILLING_UNAVAILABLE = 3;
	final static int RESULT_ITEM_UNAVAILABLE = 4;
	final static int RESULT_DEVELOPER_ERROR = 5;
	final static int RESULT_ERROR = 6;
    final static int RESULT_OK_ALREADY_PURCHASED = 7;
	
	public int TranslateControllerCodeToProtonVirtualKey(int controllerMapping, int keycode)
	{

		int result = -1;

		switch (keycode)
		{
		case KeyEvent.KEYCODE_DPAD_DOWN:
				result = VIRTUAL_KEY_DIR_DOWN;
				break;
				case KeyEvent.KEYCODE_DPAD_UP:
				result = VIRTUAL_KEY_DIR_UP;
				break;
			case KeyEvent.KEYCODE_DPAD_LEFT:
				result = VIRTUAL_KEY_DIR_LEFT;
				break;
			case KeyEvent.KEYCODE_DPAD_RIGHT:
				result = VIRTUAL_KEY_DIR_RIGHT;
				break;

			default:

		}

		if (result != -1) return result; //we're done

		//well, it's not one of the inputs that are the same across various
		//controllers, so let's get controller specific here

		//NOTE: PS5 returns 0 for O button as well as R1, I assume this is a bug and will be fixed later which will break
		//these bindings of course, because that's life.  (with latest firmware on ps5 controller, August 4th 2022)
		if (controllerMapping == C_CONTROLLER_MAPPING_PS5)
		{
			switch (keycode)
			{
			case KeyEvent.KEYCODE_BUTTON_A:
				result = VIRTUAL_DPAD_BUTTON_LEFT;
				break;

			case KeyEvent.KEYCODE_BUTTON_B:
				result = VIRTUAL_DPAD_BUTTON_DOWN;
				break;
			case KeyEvent.KEYCODE_BUTTON_Y:
				result = VIRTUAL_DPAD_BUTTON_UP;
				break;
			 case 0:
				result = VIRTUAL_DPAD_BUTTON_RIGHT;
				break;
			case KeyEvent.KEYCODE_BUTTON_X:
				result = VIRTUAL_JOYSTICK_BUTTON_LEFT;
					break;



				case KeyEvent.KEYCODE_BUTTON_SELECT:
					result = VIRTUAL_JOYSTICK_BUTTON_LEFT;
					break;
				case KeyEvent.KEYCODE_BUTTON_START:
					result = VIRTUAL_JOYSTICK_BUTTON_RIGHT;
					break;

				case KeyEvent.KEYCODE_BUTTON_R1:
					result =VIRTUAL_DPAD_RBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_L1:
					result =VIRTUAL_DPAD_LBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_R2:
					result =VIRTUAL_DPAD_START;
					break;

				case KeyEvent.KEYCODE_BUTTON_L2:
					result =VIRTUAL_DPAD_SELECT;
					break;
				default:
			}
		}

		if (controllerMapping == C_CONTROLLER_MAPPING_PS4)
		{
			switch (keycode)
			{
				case KeyEvent.KEYCODE_BUTTON_A:
					result = VIRTUAL_DPAD_BUTTON_DOWN;
					break;

				case KeyEvent.KEYCODE_BUTTON_B:
					result = VIRTUAL_DPAD_BUTTON_RIGHT;
					break;
				case KeyEvent.KEYCODE_BUTTON_Y:
					result = VIRTUAL_DPAD_BUTTON_UP;
					break;

				case KeyEvent.KEYCODE_BUTTON_X:
					result = VIRTUAL_DPAD_BUTTON_LEFT;
					break;



				case KeyEvent.KEYCODE_BUTTON_START:
					result = VIRTUAL_DPAD_START;
					break;

				case KeyEvent.KEYCODE_BUTTON_SELECT:
					result = VIRTUAL_DPAD_SELECT;
					break;


				case KeyEvent.KEYCODE_BUTTON_THUMBL:
					result = VIRTUAL_JOYSTICK_BUTTON_LEFT;
					break;
				case KeyEvent.KEYCODE_BUTTON_THUMBR:
					result = VIRTUAL_JOYSTICK_BUTTON_RIGHT;
					break;

				case KeyEvent.KEYCODE_BUTTON_R1:
					result =VIRTUAL_DPAD_RBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_L1:
					result =VIRTUAL_DPAD_LBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_R2:
					result =VIRTUAL_DPAD_RTRIGGER;
					break;

				case KeyEvent.KEYCODE_BUTTON_L2:
					result =VIRTUAL_DPAD_LTRIGGER;
					break;


				default:
			}
		}
		if (controllerMapping == C_CONTROLLER_MAPPING_8BITDO)
		{
			switch (keycode)
			{
				case KeyEvent.KEYCODE_BUTTON_A:
					result = VIRTUAL_DPAD_BUTTON_RIGHT;
					break;

				case KeyEvent.KEYCODE_BUTTON_B:
					result = VIRTUAL_DPAD_BUTTON_DOWN;
					break;
				case KeyEvent.KEYCODE_BUTTON_Y:
					result = VIRTUAL_DPAD_BUTTON_LEFT;
					break;

				case KeyEvent.KEYCODE_BUTTON_X:
					result = VIRTUAL_DPAD_BUTTON_UP;
					break;


				case KeyEvent.KEYCODE_BUTTON_START:
					result = VIRTUAL_DPAD_START;
					break;

				case KeyEvent.KEYCODE_BUTTON_SELECT:
					result = VIRTUAL_DPAD_SELECT;
					break;


				case KeyEvent.KEYCODE_BUTTON_THUMBL:
					result = VIRTUAL_JOYSTICK_BUTTON_LEFT;
					break;
				case KeyEvent.KEYCODE_BUTTON_THUMBR:
					result = VIRTUAL_JOYSTICK_BUTTON_RIGHT;
					break;

				case KeyEvent.KEYCODE_BUTTON_R1:
					result =VIRTUAL_DPAD_RBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_L1:
					result =VIRTUAL_DPAD_LBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_R2:
					result =VIRTUAL_DPAD_RTRIGGER;
					break;

				case KeyEvent.KEYCODE_BUTTON_L2:
					result =VIRTUAL_DPAD_LTRIGGER;
					break;
				default:
			}
		}
		if (controllerMapping == C_CONTROLLER_MAPPING_SWITCH_PRO)
		{
			switch (keycode)
			{
				case KeyEvent.KEYCODE_BUTTON_B:
					result = VIRTUAL_DPAD_BUTTON_RIGHT;
					break;

				case KeyEvent.KEYCODE_BUTTON_A:
					result = VIRTUAL_DPAD_BUTTON_DOWN;
					break;
				case KeyEvent.KEYCODE_BUTTON_X:
					result = VIRTUAL_DPAD_BUTTON_LEFT;
					break;

				case KeyEvent.KEYCODE_BUTTON_Y:
					result = VIRTUAL_DPAD_BUTTON_UP;
					break;


				case KeyEvent.KEYCODE_BUTTON_START:
					result = VIRTUAL_DPAD_START;
					break;

				case KeyEvent.KEYCODE_BUTTON_SELECT:
					result = VIRTUAL_DPAD_SELECT;
					break;


				case KeyEvent.KEYCODE_BUTTON_THUMBL:
					result = VIRTUAL_JOYSTICK_BUTTON_LEFT;
					break;
				case KeyEvent.KEYCODE_BUTTON_THUMBR:
					result = VIRTUAL_JOYSTICK_BUTTON_RIGHT;
					break;

				case KeyEvent.KEYCODE_BUTTON_R1:
					result =VIRTUAL_DPAD_RBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_L1:
					result =VIRTUAL_DPAD_LBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_R2:
					result =VIRTUAL_DPAD_RTRIGGER;
					break;

				case KeyEvent.KEYCODE_BUTTON_L2:
					result =VIRTUAL_DPAD_LTRIGGER;
					break;
				default:
			}
		}


		if (controllerMapping == C_CONTROLLER_MAPPING_XBOX)
		{
			switch (keycode)
			{
				case KeyEvent.KEYCODE_BUTTON_A:
					result = VIRTUAL_DPAD_BUTTON_DOWN;
					break;

				case KeyEvent.KEYCODE_BUTTON_B:
					result = VIRTUAL_DPAD_BUTTON_RIGHT;
					break;
				case KeyEvent.KEYCODE_BUTTON_Y:
					result = VIRTUAL_DPAD_BUTTON_UP;
					break;

					case KeyEvent.KEYCODE_BUTTON_X:
					result = VIRTUAL_DPAD_BUTTON_LEFT;
					break;


				case KeyEvent.KEYCODE_BUTTON_START:
					result = VIRTUAL_DPAD_START;
					break;

				case KeyEvent.KEYCODE_BUTTON_SELECT:
					result = VIRTUAL_DPAD_SELECT;
					break;


				case KeyEvent.KEYCODE_BUTTON_THUMBL:
					result = VIRTUAL_JOYSTICK_BUTTON_LEFT;
					break;
				case KeyEvent.KEYCODE_BUTTON_THUMBR:
					result = VIRTUAL_JOYSTICK_BUTTON_RIGHT;
					break;

				case KeyEvent.KEYCODE_BUTTON_R1:
					result =VIRTUAL_DPAD_RBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_L1:
					result =VIRTUAL_DPAD_LBUTTON;
					break;

				case KeyEvent.KEYCODE_BUTTON_R2:
					result =VIRTUAL_DPAD_RTRIGGER;
					break;

				case KeyEvent.KEYCODE_BUTTON_L2:
					result =VIRTUAL_DPAD_LTRIGGER;
					break;

				default:
			}
		}

		if (result != -1) return result; //we're done


		return keycode;  //uhh... don't change it?  We don't have a match
	}


	public int TranslateKeycodeToProtonVirtualKey(int keycode)
	{
		switch (keycode)
		{
			case KeyEvent.KEYCODE_BACK:
				keycode = VIRTUAL_KEY_BACK;
				break;
			case KeyEvent.KEYCODE_MENU:
				keycode = VIRTUAL_KEY_PROPERTIES;
				break;
				
			case KeyEvent.KEYCODE_SEARCH:
				keycode = VIRTUAL_KEY_SEARCH;
				break;
		
			case KeyEvent.KEYCODE_DPAD_CENTER:
				keycode = VIRTUAL_KEY_DIR_CENTER;
				break;
			
			case KeyEvent.KEYCODE_DPAD_DOWN:
				keycode = VIRTUAL_KEY_DIR_DOWN;
				break;
				case KeyEvent.KEYCODE_DPAD_UP:
				keycode = VIRTUAL_KEY_DIR_UP;
				break;
			case KeyEvent.KEYCODE_DPAD_LEFT:
				keycode = VIRTUAL_KEY_DIR_LEFT;
				break;
			case KeyEvent.KEYCODE_DPAD_RIGHT:
				keycode = VIRTUAL_KEY_DIR_RIGHT;
				break;

				
			case 59:
			case 60:

				keycode = VIRTUAL_KEY_SHIFT;
				break;
			case 113:
			case 114:
				keycode = VIRTUAL_KEY_CONTROL;
				break;
			case 57:
			case 58:
				keycode = VIRTUAL_KEY_ALT;
				break;


			case KeyEvent.KEYCODE_VOLUME_UP:
				keycode = VIRTUAL_KEY_VOLUME_UP;
				break;
			case KeyEvent.KEYCODE_VOLUME_DOWN:
				keycode = VIRTUAL_KEY_VOLUME_DOWN;
				break;

				
		}
		return keycode;
	}
	  // single touch version, works starting API4/??
    public boolean onTrackballEvent (MotionEvent e)
	{
		if (e.getAction() == MotionEvent.ACTION_MOVE)
		{
   			nativeOnTrackball(e.getX(),e.getY());
	 		//Log.d("Hey", "trackball x rel: "+e.getX()+" y rel: "+e.getY());
			return true; //signal that we handled it, so its messages don't show up as normal directional presses
		} 
		else if (e.getAction() == MotionEvent.ACTION_DOWN)
		{
			//they pushed the button
			//Log.d("Hey", "Trackball button pushed");
			nativeOnKey(1, VIRTUAL_KEY_TRACKBALL_DOWN, VIRTUAL_KEY_TRACKBALL_DOWN); 
		}
		return false; 
	}

	boolean isController(int device) 
	{
		return ((device & InputDevice.SOURCE_CLASS_JOYSTICK) == InputDevice.SOURCE_CLASS_JOYSTICK)
      || (((device & InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD));
	}


@Override
		public boolean onKeyMultiple (int keyCode, 
                int count, 
                KeyEvent event)
                {
        			//Log.v("***** onKeyMultiple",count+" keys pressed! First was "+keyCode+" "+Character.toString(Character.toChars(event.getUnicodeChar())[0]));
        			return super.onKeyMultiple(keyCode, count, event);
                }
@Override
	public boolean onKeyDown(int keycode, KeyEvent e) 
	{
	//    Log.v("onKeyDown","Keydown Got "+keycode+" "+Character.toString(Character.toChars(e.getUnicodeChar())[0])
	//	+" External: "+e.getSource()+" Is alt pressed: "+e.isAltPressed());
  
		if (keycode == 67)
		{
			//Log.v("onKeyUp", "Detected delete, ignoring, we handle it a different way now");
			return true;			
		}
		if (e.getRepeatCount() > 0) 
			return super.onKeyDown(keycode, e);

	  	if(isController(e.getSource())) 
		{
			//is it an xbox or ps5 pad?
			if (!m_gamepadMap.containsKey(e.getDeviceId()))
			{
				//we don't know what it is, go look at the name and fill in this data
				//Log.v("Debug", "Checking controllers...");
				CheckControllers();
			}
		    int protonCode = TranslateControllerCodeToProtonVirtualKey(m_gamepadMap.get(e.getDeviceId()), keycode);
			if (protonCode != -1)
		    {
			
		    	nativeOnKey(1, protonCode, 0);
		    } else
			{
				//Log.v("Debug", "Ignoring controller keycode: "+keycode+" as the proton code is "+protonCode);
			}
		
			return true; //signal that we handled it
		}
		
		//do we want this?  Read somewhere it helps with some issues relating to foreign keyboard input..
		//if(keycode==KeyEvent.KEYCODE_ALT_LEFT || keycode==KeyEvent.KEYCODE_ALT_RIGHT || keycode==KeyEvent.KEYCODE_SHIFT_LEFT || keycode==KeyEvent.KEYCODE_SHIFT_RIGHT) return true;

        switch (keycode)
		{
			case KeyEvent.KEYCODE_BACK:
			{
				nativeOnKey(1, VIRTUAL_KEY_BACK, e.getUnicodeChar());
				return true; //signal that we handled it
			}
		}
		
		int vKey = TranslateKeycodeToProtonVirtualKey(keycode);
		nativeOnKey(1, vKey, (char)e.getUnicodeChar()); //1  means keydown
        return super.onKeyDown(keycode, e);
    }
	
@Override
    public boolean onKeyUp(int keycode, KeyEvent e)
	{
		//Log.v("onKeyUp","Keyup Got "+keycode+" "+Character.toString(Character.toChars(e.getUnicodeChar())[0]));
     	if (keycode == 67)
		{
			//Log.v("onKeyUp", "Detected delete, ignoring, we handle it a different way now");
			return true;			
		}

		if(isController(e.getSource()))
		{
			//is it an xbox or ps5 pad?
			if (!m_gamepadMap.containsKey(e.getDeviceId()))
			{
				//we don't know what it is, go look at the name and fill in this data
				//Log.v("Debug", "Checking controllers...");
				CheckControllers();
			}
			int protonCode = TranslateControllerCodeToProtonVirtualKey(m_gamepadMap.get(e.getDeviceId()), keycode);
			if (protonCode != -1)
			{
				nativeOnKey(0, protonCode, 0);
			} else
			{
			//	Log.v("Debug", "Ignoring controller keycode" +	": "+keycode+" as the proton code is "+protonCode);
			}

			return true; //signal that we handled it
		}

		switch (keycode)
		{
			case KeyEvent.KEYCODE_BACK:
			{
				nativeOnKey(0, VIRTUAL_KEY_BACK, e.getUnicodeChar()); //0 is type keyup
				return true; //signal that we handled it
			}
		}

      	int vKey = TranslateKeycodeToProtonVirtualKey(keycode);
	
      	nativeOnKey(0, vKey,(char)e.getUnicodeChar()); //0 is type keyup
		return super.onKeyUp(keycode, e);
    }
   

	// straight version
	public void sendVersionDetails()
	{
		//Log.v(app.PackageName, "Attempting to send app version");
		PackageInfo pInfo;
		try {
			pInfo = getPackageManager().getPackageInfo(getPackageName(), 0);
			//Log.v(app.PackageName, "Sending version");
			nativeSendGUIStringEx(MESSAGE_TYPE_APP_VERSION, 0,0,0, pInfo.versionName);
		}
		catch (NameNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			Log.d(app.PackageName, "Cannot load App Version!");
		}
	}
  

	//***************************
    
	//************** SOUND STUFF *************

	// JNI to play music, etc
	public MediaPlayer _music = null;
	
	private static class MusicFadeOutThread extends Thread {
		private final int m_duration;

		public MusicFadeOutThread(int duration)
		{
			super();
			m_duration = duration;
		}

		public void run()
		{
			final int volumeChangeInterval = 100;  // change volume every this amount of ms
			final int totalSteps = m_duration / volumeChangeInterval;
			int remainingSteps = totalSteps;
			
			while (remainingSteps > 0)
			{
				synchronized (app._music)
				{
					float phase = (float)remainingSteps / (float)totalSteps;
					app._music.setVolume(phase * m_lastMusicVol, phase * m_lastMusicVol);
					remainingSteps--;
				}
				
				try {
					Thread.sleep(volumeChangeInterval);
				} 
				catch (InterruptedException ie)
				{
					return;
				}
			}

			synchronized (app._music)
			{
				app._music.stop();
				app._music.setVolume(m_lastMusicVol, m_lastMusicVol);
			}
		}
	}
	
	private MusicFadeOutThread musicFadeOutThread = null;

	public synchronized static void music_play(String fname, boolean looping)
	{
		if (app._music != null)
		{
			app._music.reset();
		} 
		else
		{
			app._music = new MediaPlayer();
		}
		
		if (fname.charAt(0) == '/')
		{
			//load as raw, not an asset
			try {
				File file = new File(fname);
				FileInputStream is = new FileInputStream(file);
				app._music.setDataSource(is.getFD());
				is.close();
				app._music.setLooping(looping);
				app._music.prepare();
				music_set_volume(m_lastMusicVol);
				app._music.start();
			} 
			catch(IOException e) 
			{ 
				Log.d("Can't load music (raw)", fname, e);
			}
			catch(IllegalStateException e) 
			{ 
				Log.d("Can't load music (raw),", fname);
				app._music.reset();
			}
			return;
		}

		AssetManager am = app.getAssets();
		try { 
			AssetFileDescriptor fd = am.openFd(fname);
			app._music.setDataSource(fd.getFileDescriptor(),fd.getStartOffset(),fd.getLength());
			fd.close();
			app._music.setLooping(looping);
			app._music.prepare();
			music_set_volume(m_lastMusicVol);
			app._music.start();
		} 
		catch(IOException e) 
		{ 
			Log.d("Can't load music", fname);
		}
		catch(IllegalStateException e) 
		{ 
			Log.d("Can't load music!", fname);
			app._music.reset();
		}
	}

	public synchronized static void music_stop() 
	{
		if (app._music == null) { return; }
		
		if (app.musicFadeOutThread != null && app.musicFadeOutThread.isAlive()) {
			try {
				app.musicFadeOutThread.interrupt();
				app.musicFadeOutThread.join();
			} 
			catch (InterruptedException ie)
			{
			}
		}
		
		app._music.stop();
	}
	
	public synchronized static void music_fadeout(int duration)
	{
		if (app._music == null || !app._music.isPlaying())
		{
			return;
		}
		
		if (duration <= 0)
		{
			music_stop();
		} 
		else if (app.musicFadeOutThread == null || !app.musicFadeOutThread.isAlive())
		{
			app.musicFadeOutThread = new MusicFadeOutThread(duration);
			app.musicFadeOutThread.start();
		}
	}

	public synchronized static void music_set_volume(float v) 
	{
		if (app._music == null) 
		{ 
			return; 
		}
		m_lastMusicVol = v;
		app._music.setVolume(v,v);
	}

    public synchronized static void vibrate(int vibMS) 
	{
		/*
		//lint don't like it with the permission
        Vibrator v = (Vibrator) app.getSystemService(Context.VIBRATOR_SERVICE);
		v.vibrate(vibMS);
		*/
    }

    public synchronized static int music_get_pos() 
	{
        if (app._music == null) 
		{ 
			return 0; 
		}
        return app._music.getCurrentPosition();
    }
  
	public synchronized static boolean music_is_playing() 
	{
        if (app._music == null) 
		{ 
			return false; 
		}
        return app._music.isPlaying();
    }

    public synchronized static void music_set_pos(int positionMS) 
	{
        if (app._music == null) 
		{
			Log.d("music_set_position:", "no music playing");
			return; 
		}
		app._music.seekTo(positionMS);
    }

	// JNI to play sounds
    public SoundPool _sounds = new SoundPool(8,AudioManager.STREAM_MUSIC,0);
    
	public synchronized static void sound_init()
	{
		if (app._sounds == null)
		{
			app._sounds = new SoundPool(8,AudioManager.STREAM_MUSIC,0);
		}
	}

	public synchronized static void sound_destroy()
	{
		if (app._sounds != null)
		{
			app._sounds.release();
			app._sounds = null;
		}
	}

	public synchronized static int sound_load(String fname) 
	{
       // Log.v("sound_load",fname);
       
		if (fname.charAt(0) == '/')
		{
			//must be a raw file on the disc, not in the assets.  load differently
			int sid = app._sounds.load(fname, 1);
			return sid;
		}
		
		AssetManager am = app.getAssets();
        try { 
            AssetFileDescriptor fd = am.openFd(fname);
            int sid = app._sounds.load(fd.getFileDescriptor(),fd.getStartOffset(),fd.getLength(),1);
            return sid;
        } 
		catch(IOException e)
		{
			Log.d("Can't load sound", fname);
		}
        return 0;
    }

    public synchronized static int sound_play(int soundID, float leftVol, float rightVol, int priority, int loop, float speedMod ) 
	{
		//Log.v("MSG", "Playing sound: "+soundID);
		//Log.v("Sound vol:", ""+leftVol);
        return app._sounds.play(soundID,leftVol,rightVol,priority,loop,speedMod);
    }
  
	public static void sound_kill(int soundID ) 
	{
		//Log.v("MSG", "killing sound: "+soundID);
       app._sounds.unload(soundID);
    }

	public static void sound_stop(int streamID ) 
	{
		//Log.v("MSG", "stopping sound: "+streamID);
		//Log.v("Sound vol:", ""+leftVol);
        app._sounds.stop(streamID);
    }

	public static void sound_set_vol(int streamID, float left, float right ) 
	{
		//Log.v("MSG", "setting sound vol: "+streamID);
		//Log.v("Sound vol:", ""+left);
        app._sounds.setVolume(streamID, left, right);
    }
	public static void sound_set_rate(int streamID, float rate ) 
	{
		//Log.v("MSG", "Playing sound: "+soundID);
		//Log.v("Sound vol:", ""+leftVol);
        app._sounds.setRate(streamID, rate);
    }

	//****************************************

	public GLSurfaceView mGLView;
	public static native void nativeOnKey(int type, int keycode, int c);
	public static native void nativeOnTrackball(float x, float y);
	public static native void nativeOnAccelerometerUpdate(float x, float y, float z);
	public static native void nativeSendGUIEx(int messageType, int parm1, int parm2, int finger);
	public static native void nativeSendGUIStringEx(int messageType, int parm1, int parm2, int finger, String s);
	static 
    { 
		//System.loadLibrary(dllname);
    }
}

class AppGLSurfaceView extends GLSurfaceView
{

    public AppGLSurfaceView(Context context, SharedActivity _app) 
	{
    	super(context);
        app = _app;
		
		if (app.m_editText != null)
		{
			Log.d(app.PackageName, "Setting focus options...");
			this.setFocusable(true);
			this.setFocusableInTouchMode(true);
			this.requestFocus();
		}
		//Log.d(app.PackageName, "Setup focus");

		//setEGLConfigChooser(8, 8, 8, 8, 16, 0);
		//getHolder().setFormat(PixelFormat.TRANSLUCENT);
		
		mRenderer = new AppRenderer(_app);
		setRenderer(mRenderer);
	
		/* establish whether the "new" class is available to us */
  
	 try
	   {
		   WrapSharedMultiTouchInput.checkAvailable(app);
           mMultiTouchClassAvailable = true;
       } catch (Throwable t) 
	   {
           mMultiTouchClassAvailable = false;
       }
	}
    	
	public void onPause() 
    {
        super.onPause();

		if (app.bIsShuttingDown == false)
		{
			nativePause();   
		}
    }
    
	public void onResume() 
    {
        super.onResume();

		if (app.bIsShuttingDown == false)
		{
			nativeResume();   
		}
	}
		
    // single touch version, works starting API4/??
    public synchronized boolean onTouchEvent(final MotionEvent e)
	{

		if (mMultiTouchClassAvailable) 
		{
			return WrapSharedMultiTouchInput.OnInput(e);
		} 
		else
		{
			float x = e.getX(); float y = e.getY();
     		int finger = 0; //planning ahead for multi touch
			nativeOnTouch(e.getAction(), x,y,finger);
		}
		return true;
    }
    

	AppRenderer mRenderer;

	private static native void nativePause();
	private static native void nativeResume();
	public static native void nativeOnTouch(int action, float x, float y, int finger);
	public SharedActivity app;
	private static boolean mMultiTouchClassAvailable;
}

class WrapSharedMultiTouchInput
{
	private SharedMultiTouchInput mInstance;

	/* class initialization fails when this throws an exception */
   static 
   {
       try
	   {
          Class.forName("com.rtsoft.RTAndroidApp.SharedMultiTouchInput");
       } 
	   catch (Exception ex) 
	   {
           throw new RuntimeException(ex);
       }
   }

   /* calling here forces class initialization */
   public static void checkAvailable(SharedActivity _app)
   {
	   SharedMultiTouchInput.init(_app);
   }

   public static boolean OnInput(final MotionEvent e)
   {
       return SharedMultiTouchInput.OnInput(e);
   }
}

class AppRenderer implements GLSurfaceView.Renderer 
{
	public AppRenderer(SharedActivity _app)
	{
		app = _app;
	}

	public void onSurfaceCreated(GL10 gl, EGLConfig config)
    {
	 

    }

    public void onSurfaceChanged(GL10 gl, int w, int h) 
    {
        //gl.glViewport(0, 0, w, h);
        nativeResize(w, h);
        nativeInit();
    }
	
	//don't change the order of these defines, they match the ones in Proton!
		
	//messages that might be sent to us from Proton's C++ side
	final static int MESSAGE_NONE = 0;
	final static int MESSAGE_OPEN_TEXT_BOX = 1;
	final static int MESSAGE_CLOSE_TEXT_BOX = 2;
	final static int MESSAGE_CHECK_CONNECTION = 3;
	final static int MESSAGE_SET_FPS_LIMIT = 4;
	final static int MESSAGE_SET_ACCELEROMETER_UPDATE_HZ = 5;
	final static int MESSAGE_FINISH_APP = 6; //only respected by windows and android right now.  webos and iphone don't really need it
	final static int MESSAGE_SET_VIDEO_MODE = 7; 

	final static int MESSAGE_TAPJOY_GET_FEATURED_APP = 8; 
	final static int MESSAGE_TAPJOY_GET_AD = 9; 
	final static int MESSAGE_TAPJOY_GET_MOVIE = 10; 

	final static int MESSAGE_TAPJOY_SHOW_FEATURED_APP = 11; 
	final static int MESSAGE_TAPJOY_SHOW_AD = 12; 
	final static int MESSAGE_TAPJOY_SHOW_MOVIE_AD = 13; 
	
	final static int MESSAGE_IAP_PURCHASE = 14;
	final static int MESSAGE_IAP_GET_PURCHASED_LIST = 15;
	final static int MESSAGE_IAP_ITEM_DETAILS = 39;
	
	final static int MESSAGE_TAPJOY_GET_TAP_POINTS = 16;
	final static int MESSAGE_TAPJOY_SPEND_TAP_POINTS = 17;
	final static int MESSAGE_TAPJOY_AWARD_TAP_POINTS = 18;
	final static int MESSAGE_TAPJOY_SHOW_OFFERS = 19;
	final static int MESSAGE_HOOKED_SHOW_RATE_DIALOG = 20;
	final static int MESSAGE_ALLOW_SCREEN_DIMMING = 21;
	final static int MESSAGE_REQUEST_AD_SIZE = 22;

	//CHARTBOOST STUFF

	final static int MESSAGE_CHARTBOOST_CACHE_INTERSTITIAL = 23;
	final static int MESSAGE_CHARTBOOST_SHOW_INTERSTITIAL = 24;
	final static int MESSAGE_CHARTBOOST_CACHE_MORE_APPS = 25;
	final static int MESSAGE_CHARTBOOST_SHOW_MORE_APPS = 26;
	final static int MESSAGE_CHARTBOOST_SETUP = 27;
	final static int MESSAGE_CHARTBOOST_NOTIFY_INSTALL = 28;
	final static int MESSAGE_CHARTBOOST_RESERVED1 = 29;
	final static int MESSAGE_CHARTBOOST_RESERVED2 = 30;

	//FLURRY
	final static int MESSAGE_FLURRY_SETUP = 31;
	final static int MESSAGE_FLURRY_ON_PAGE_VIEW = 32;
	final static int MESSAGE_FLURRY_LOG_EVENT = 33;
	
	final static int MESSAGE_SUSPEND_TO_HOME_SCREEN = 34;

	//TJ AGAIN
	final static int MESSAGE_TAPJOY_INIT_MAIN = 35;
	final static int MESSAGE_TAPJOY_INIT_PAID_APP_WITH_ACTIONID = 36;
	final static int MESSAGE_TAPJOY_SET_USERID = 37;

	//IAP again
	final static int MESSAGE_IAP_CONSUME_ITEM = 38;

	static long m_gameTimer = 0;
	static int m_timerLoopMS = 0; //every this MS, the loop runs.  0 for no fps limit
	final static int MESSAGE_FLURRY_START_TIMED_EVENT = 1001;
	final static int MESSAGE_FLURRY_STOP_TIMED_EVENT = 1002;

	// Appsflyer logging puchase
	final static int MESSAGE_APPSFLYER_LOG_PURCHASE = 40;
	
    public synchronized void onDrawFrame(GL10 gl)
    {
		if (m_timerLoopMS != 0)
		{
			while (m_gameTimer > SystemClock.uptimeMillis() || m_gameTimer > SystemClock.uptimeMillis()+m_timerLoopMS+1)
			{
				//wait a bit - no exception catch needed for the SystemClock version of sleep
				SystemClock.sleep(1); 
			} 
		
			m_gameTimer = SystemClock.uptimeMillis()+m_timerLoopMS;
		}
	
		if (!app.bIsShuttingDown)
		{
			nativeUpdate(); //maybe later we'll want to adjust this for performance reasons..
			nativeRender();
        }

		//let's process OS messages sent from the app if any exist
		int type = MESSAGE_NONE;

		while ( (type = nativeOSMessageGet()) != 0) //it returns 0 if none is available
		{
			switch (type)
			{
				case MESSAGE_OPEN_TEXT_BOX: //open text box
					
					app.m_text_max_length = nativeGetLastOSMessageParm1();
					app.m_text_default = SharedActivity.app.m_spacer;
					
					app.m_before =  app.m_text_default;
					app.toggle_keyboard(true);
					app.mMainThreadHandler.post(app.mUpdateMainThread);
					break;

				case MESSAGE_CLOSE_TEXT_BOX: //close text box
					app.toggle_keyboard(false);
					app.mMainThreadHandler.post(app.mUpdateMainThread);

					break;
		
				case MESSAGE_SET_ACCELEROMETER_UPDATE_HZ: 
					app.setup_accel(nativeGetLastOSMessageX());
					break;

				case MESSAGE_ALLOW_SCREEN_DIMMING: 
					if (nativeGetLastOSMessageX() == 0)
					{
						//disable screen dimming
						app.set_disallow_dimming_asap = true; //must do it in the UI thread
						app.mMainThreadHandler.post(app.mUpdateMainThread);

					} else
					{
						Log.v(app.PackageName, "Allowing screen dimming.");
						app.set_allow_dimming_asap = true; //must do it in the UI thread
						app.mMainThreadHandler.post(app.mUpdateMainThread);

					}
					break;

				case MESSAGE_SET_FPS_LIMIT: 
					if (nativeGetLastOSMessageX() == 0)
					{
						//disable it, and avoid a div by 0
						m_timerLoopMS = 0;
					} 
					else
					{
						m_timerLoopMS = (int) (1000.0f/nativeGetLastOSMessageX());
					}
				
					//app.setup_accel(nativeGetLastOSMessageX());
					break;

				case MESSAGE_FINISH_APP: 
					Log.v(app.PackageName, "Finishing app from java side");
					app.bIsShuttingDown = true;
					nativeDone();
					Log.v(app.PackageName, "Native shutdown");
			
					//app.finish() will get called in the update handler called below, don't need to do it now
					app.mMainThreadHandler.post(app.mUpdateMainThread);
					break;
				
				case MESSAGE_SUSPEND_TO_HOME_SCREEN:
					Log.v(app.PackageName, "Suspending to home screen");
					
					Intent i = new Intent();
					i.setAction(Intent.ACTION_MAIN);
			        i.addCategory(Intent.CATEGORY_HOME);
					app.startActivity(i);
					break;


				default:
					Log.v("Unhandled","Unhandled OS message");
			}
		}
    }

    private static native void nativeInit();
    private static native void nativeResize(int w, int h);
    private static native void nativeUpdate();
    private static native void nativeRender();
    private static native void nativeDone();
	
	//yes, I probably should do this as a Java class and init it from C++ and send that over but..

	private static native int nativeOSMessageGet();
	private static native int nativeGetLastOSMessageParm1();
	private static native float nativeGetLastOSMessageX();
	private static native float nativeGetLastOSMessageY();
	private static native String nativeGetLastOSMessageString();
	private static native String nativeGetLastOSMessageString2();
	private static native String nativeGetLastOSMessageString3();
	public SharedActivity app;
}
